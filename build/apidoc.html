<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://mikolalysenko.github.io/regl"

    >regl (v1.3.0)</a>
</h1>
<h4>regl is a fast functional WebGL framework.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl">module regl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.regl">
            function <span class="apidocSignatureSpan"></span>regl
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check">
            function <span class="apidocSignatureSpan">regl.</span>check
            <span class="apidocSignatureSpan">(pred, message)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>dynamic</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>flatten</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>pool</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>raf</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.check">module regl.check</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.check">
            function <span class="apidocSignatureSpan">regl.</span>check
            <span class="apidocSignatureSpan">(pred, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.callSite">
            function <span class="apidocSignatureSpan">regl.check.</span>callSite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.command">
            function <span class="apidocSignatureSpan">regl.check.</span>command
            <span class="apidocSignatureSpan">(pred, message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.commandParameter">
            function <span class="apidocSignatureSpan">regl.check.</span>commandParameter
            <span class="apidocSignatureSpan">(param, possibilities, message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.commandRaise">
            function <span class="apidocSignatureSpan">regl.check.</span>commandRaise
            <span class="apidocSignatureSpan">(message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.commandType">
            function <span class="apidocSignatureSpan">regl.check.</span>commandType
            <span class="apidocSignatureSpan">(value, type, message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.constructor">
            function <span class="apidocSignatureSpan">regl.check.</span>constructor
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.framebufferFormat">
            function <span class="apidocSignatureSpan">regl.check.</span>framebufferFormat
            <span class="apidocSignatureSpan">(attachment, texFormats, rbFormats)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.guessCommand">
            function <span class="apidocSignatureSpan">regl.check.</span>guessCommand
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.isTypedArray">
            function <span class="apidocSignatureSpan">regl.check.</span>isTypedArray
            <span class="apidocSignatureSpan">(data, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.linkError">
            function <span class="apidocSignatureSpan">regl.check.</span>linkError
            <span class="apidocSignatureSpan">(gl, program, fragShader, vertShader, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.nni">
            function <span class="apidocSignatureSpan">regl.check.</span>nni
            <span class="apidocSignatureSpan">(value, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.oneOf">
            function <span class="apidocSignatureSpan">regl.check.</span>oneOf
            <span class="apidocSignatureSpan">(value, list, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.optional">
            function <span class="apidocSignatureSpan">regl.check.</span>optional
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.parameter">
            function <span class="apidocSignatureSpan">regl.check.</span>parameter
            <span class="apidocSignatureSpan">(param, possibilities, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.raise">
            function <span class="apidocSignatureSpan">regl.check.</span>raise
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.saveCommandRef">
            function <span class="apidocSignatureSpan">regl.check.</span>saveCommandRef
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.saveDrawInfo">
            function <span class="apidocSignatureSpan">regl.check.</span>saveDrawInfo
            <span class="apidocSignatureSpan">(opts, uniforms, attributes, stringStore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.shaderError">
            function <span class="apidocSignatureSpan">regl.check.</span>shaderError
            <span class="apidocSignatureSpan">(gl, shader, source, type, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.texture2D">
            function <span class="apidocSignatureSpan">regl.check.</span>texture2D
            <span class="apidocSignatureSpan">(info, mipData, limits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.textureCube">
            function <span class="apidocSignatureSpan">regl.check.</span>textureCube
            <span class="apidocSignatureSpan">(texture, info, faces, limits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.type">
            function <span class="apidocSignatureSpan">regl.check.</span>type
            <span class="apidocSignatureSpan">(value, type, message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.dynamic">module regl.dynamic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.DynamicVariable">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>DynamicVariable
            <span class="apidocSignatureSpan">(type, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.accessor">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>accessor
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.define">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>define
            <span class="apidocSignatureSpan">(type, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.isDynamic">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>isDynamic
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.unbox">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>unbox
            <span class="apidocSignatureSpan">(x, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.flatten">module regl.flatten</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.flatten.flatten">
            function <span class="apidocSignatureSpan">regl.</span>flatten
            <span class="apidocSignatureSpan">(array, shape, type, out_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.flatten.shape">
            function <span class="apidocSignatureSpan">regl.flatten.</span>shape
            <span class="apidocSignatureSpan">(array_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.pool">module regl.pool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.alloc">
            function <span class="apidocSignatureSpan">regl.pool.</span>alloc
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.allocType">
            function <span class="apidocSignatureSpan">regl.pool.</span>allocType
            <span class="apidocSignatureSpan">(type, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.free">
            function <span class="apidocSignatureSpan">regl.pool.</span>free
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.freeType">
            function <span class="apidocSignatureSpan">regl.pool.</span>freeType
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.raf">module regl.raf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.raf.cancel">
            function <span class="apidocSignatureSpan">regl.raf.</span>cancel
            <span class="apidocSignatureSpan">(timer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.raf.next">
            function <span class="apidocSignatureSpan">regl.raf.</span>next
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl" id="apidoc.module.regl">module regl</a></h1>


    <h2>
        <a href="#apidoc.element.regl.regl" id="apidoc.element.regl.regl">
        function <span class="apidocSignatureSpan"></span>regl
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapREGL(args) {
  var config = parseArgs(args);
  if (!config) {
    return null
  }

  var gl = config.gl;
  var glAttributes = gl.getContextAttributes();
  var contextLost = gl.isContextLost();

  var extensionState = createExtensionCache(gl, config);
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore();
  var stats$$1 = stats();
  var extensions = extensionState.extensions;
  var timer = createTimer(gl, extensions);

  var START_TIME = clock();
  var WIDTH = gl.drawingBufferWidth;
  var HEIGHT = gl.drawingBufferHeight;

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  };
  var uniformState = {};
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  };

  var limits = wrapLimits(gl, extensions);
  var bufferState = wrapBufferState(gl, stats$$1, config);
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    bufferState,
    stringStore);
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll(); },
    contextState,
    stats$$1,
    config);
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1);
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config);
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions);

  var nextState = core.next;
  var canvas = gl.canvas;

  var rafCallbacks = [];
  var lossCallbacks = [];
  var restoreCallbacks = [];
  var destroyCallbacks = [config.onDestroy];

  var activeRAF = null;
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update();
      }
      activeRAF = null;
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF);

    // poll for changes
    poll();

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i &#x3e;= 0; --i) {
      var cb = rafCallbacks[i];
      if (cb) {
        cb(contextState, null, 0);
      }
    }

    // flush all pending webgl calls
    gl.flush();

    // poll GPU timers *after* gl.flush so we don&#x27;t delay command dispatch
    if (timer) {
      timer.update();
    }
  }

  function startRAF () {
    if (!activeRAF &#x26;&#x26; rafCallbacks.length &#x3e; 0) {
      activeRAF = raf.next(handleRAF);
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF);
      activeRAF = null;
    }
  }

  function handleContextLoss (event) {
    event.preventDefault();

    // set context lost flag
    contextLost = true;

    // pause request animation frame
    stopRAF();

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb();
    });
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError();

    // clear context lost flag
    contextLost = false;

    // refresh state
    extensionState.restore();
    shaderState.restore();
    bufferState.restore();
    textureState.restore();
    renderbufferState.restore();
    framebufferState.restore();
    if (timer) {
      timer.restore();
    }

    // refresh state
    core.procs.refresh();

    // restart RAF
    startRAF();

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb();
    });
  }

  if (canvas) {
    canvas.addEventListener(CO ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check" id="apidoc.element.regl.check">
        function <span class="apidocSignatureSpan">regl.</span>check
        <span class="apidocSignatureSpan">(pred, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check(pred, message) {
  if (!pred) {
    raise(message)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.check" id="apidoc.module.regl.check">module regl.check</a></h1>


    <h2>
        <a href="#apidoc.element.regl.check.check" id="apidoc.element.regl.check.check">
        function <span class="apidocSignatureSpan">regl.</span>check
        <span class="apidocSignatureSpan">(pred, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check(pred, message) {
  if (!pred) {
    raise(message)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.callSite" id="apidoc.element.regl.check.callSite">
        function <span class="apidocSignatureSpan">regl.check.</span>callSite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function guessCallSite() {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return &#x27;unknown&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.command" id="apidoc.element.regl.check.command">
        function <span class="apidocSignatureSpan">regl.check.</span>command
        <span class="apidocSignatureSpan">(pred, message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkCommand(pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
programList.length = 0;
programCache = {};

stats.shaderCount = 0;
    },

    program: function (vertId, fragId, command) {
check$1.<span class="apidocCodeKeywordSpan">command</span>(vertId &#x3e;= 0, &#x27;missing vertex shader&#x27;, command);
check$1.command(fragId &#x3e;= 0, &#x27;missing fragment shader&#x27;, command);

var cache = programCache[fragId];
if (!cache) {
  cache = programCache[fragId] = {};
}
var program = cache[vertId];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.commandParameter" id="apidoc.element.regl.check.commandParameter">
        function <span class="apidocSignatureSpan">regl.check.</span>commandParameter
        <span class="apidocSignatureSpan">(param, possibilities, message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkParameterCommand(param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      &#x27;unknown parameter (&#x27; + param + &#x27;)&#x27; + encolon(message) +
      &#x27;. possible values: &#x27; + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var elements = parseElements();

function parsePrimitive () {
  if (S_PRIMITIVE in staticOptions) {
    var primitive = staticOptions[S_PRIMITIVE];
    check$1.<span class="apidocCodeKeywordSpan">commandParameter</span>(primitive, primTypes, &#x27;invalid primitve&#x27;, env.
commandStr);
    return createStaticDecl(function (env, scope) {
      return primTypes[primitive]
    })
  } else if (S_PRIMITIVE in dynamicOptions) {
    var dynPrimitive = dynamicOptions[S_PRIMITIVE];
    return createDynamicDecl(dynPrimitive, function (env, scope) {
      var PRIM_TYPES = env.constants.primTypes;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.commandRaise" id="apidoc.element.regl.check.commandRaise">
        function <span class="apidocSignatureSpan">regl.check.</span>commandRaise
        <span class="apidocSignatureSpan">(message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function commandRaise(message, command) {
  var callSite = guessCallSite()
  raise(message +
    &#x27; in command &#x27; + (command || guessCommand()) +
    (callSite === &#x27;unknown&#x27; ? &#x27;&#x27; : &#x27; called from &#x27; + callSite))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
check$1.optional(function () {
  env.CHECK = link(check$1);
  env.commandStr = check$1.guessCommand();
  env.command = link(env.commandStr);
  env.assert = function (block, pred, message) {
    block(
      &#x27;if(!(&#x27;, pred, &#x27;))&#x27;,
      this.CHECK, &#x27;.<span class="apidocCodeKeywordSpan">commandRaise</span>(&#x27;, link(message), &#x27;,&#x27;, this.command
, &#x27;);&#x27;);
  };

  sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
});

// Copy GL state variables over
var nextVars = env.next = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.commandType" id="apidoc.element.regl.check.commandType">
        function <span class="apidocSignatureSpan">regl.check.</span>commandType
        <span class="apidocSignatureSpan">(value, type, message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkCommandType(value, type, message, command) {
  if (typeof value !== type) {
    commandRaise(
      &#x27;invalid parameter type&#x27; + encolon(message) +
      &#x27;. expected &#x27; + type + &#x27;, got &#x27; + (typeof value),
      command || guessCommand())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static;
    var dynamicOptions = options.dynamic;

    function parseBox (param) {
      if (param in staticOptions) {
var box = staticOptions[param];
check$1.<span class="apidocCodeKeywordSpan">commandType</span>(box, &#x27;object&#x27;, &#x27;invalid &#x27; + param, env.commandStr
);

var isStatic = true;
var x = box.x | 0;
var y = box.y | 0;
var w, h;
if (&#x27;width&#x27; in box) {
  w = box.width | 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.constructor" id="apidoc.element.regl.check.constructor">
        function <span class="apidocSignatureSpan">regl.check.</span>constructor
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkConstructor(obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) &#x3c; 0) {
      raise(&#x27;invalid regl constructor argument &#x22;&#x27; + key + &#x27;&#x22;. must be one of &#x27; + constructorKeys)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else if (typeof args === &#x27;object&#x27;) {
if (isHTMLElement(args)) {
  element = args;
} else if (isWebGLContext(args)) {
  gl = args;
  canvas = gl.canvas;
} else {
  check$1.<span class="apidocCodeKeywordSpan">constructor</span>(args);
  if (&#x27;gl&#x27; in args) {
    gl = args.gl;
  } else if (&#x27;canvas&#x27; in args) {
    canvas = getElement(args.canvas);
  } else if (&#x27;container&#x27; in args) {
    container = getElement(args.container);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.framebufferFormat" id="apidoc.element.regl.check.framebufferFormat">
        function <span class="apidocSignatureSpan">regl.check.</span>framebufferFormat
        <span class="apidocSignatureSpan">(attachment, texFormats, rbFormats)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkFramebufferFormat(attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      &#x27;unsupported texture format for attachment&#x27;)
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      &#x27;unsupported renderbuffer format for attachment&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.guessCommand" id="apidoc.element.regl.check.guessCommand">
        function <span class="apidocSignatureSpan">regl.check.</span>guessCommand
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function guessCommand() {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return &#x27;unknown&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Object.keys(sharedState).forEach(function (prop) {
  shared[prop] = global.def(SHARED, &#x27;.&#x27;, prop);
});

// Inject runtime assertion stuff for debug builds
check$1.optional(function () {
  env.CHECK = link(check$1);
  env.commandStr = check$1.<span class="apidocCodeKeywordSpan">guessCommand</span>();
  env.command = link(env.commandStr);
  env.assert = function (block, pred, message) {
    block(
      &#x27;if(!(&#x27;, pred, &#x27;))&#x27;,
      this.CHECK, &#x27;.commandRaise(&#x27;, link(message), &#x27;,&#x27;, this.command, &#x27;);&#x27;);
  };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.isTypedArray" id="apidoc.element.regl.check.isTypedArray">
        function <span class="apidocSignatureSpan">regl.check.</span>isTypedArray
        <span class="apidocSignatureSpan">(data, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkIsTypedArray(data, message) {
  if (!isTypedArray(data)) {
    raise(
      &#x27;invalid parameter type&#x27; + encolon(message) +
      &#x27;. must be a typed array&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    data = new Uint8Array(size);
  } else if (type === GL_FLOAT$6) {
    data = data || new Float32Array(size);
  }
}

// Type check
check$1.<span class="apidocCodeKeywordSpan">isTypedArray</span>(data, &#x27;data buffer for regl.read() must be a typedarray&#x27
;);
check$1(data.byteLength &#x3e;= size, &#x27;data buffer for regl.read() too small&#x27;);

// Run read pixels
gl.pixelStorei(GL_PACK_ALIGNMENT, 4);
gl.readPixels(x, y, width, height, GL_RGBA$2,
              type,
              data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.linkError" id="apidoc.element.regl.check.linkError">
        function <span class="apidocSignatureSpan">regl.check.</span>linkError
        <span class="apidocSignatureSpan">(gl, program, fragShader, vertShader, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkLinkError(gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = &#x27;Error linking program with vertex shader, &#x22;&#x27; +
      vertParse[0].name + &#x27;&#x22;, and fragment shader &#x22;&#x27; + fragParse[0].name + &#x27;&#x22;&#x27;

    if (typeof document !== &#x27;undefined&#x27;) {
      console.log(&#x27;%c&#x27; + header + &#x27;\n%c&#x27; + errLog,
        &#x27;color:red;text-decoration:underline;font-weight:bold&#x27;,
        &#x27;color:red&#x27;)
    } else {
      console.log(header + &#x27;\n&#x27; + errLog)
    }
    check.raise(header)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);

var program = desc.program = gl.createProgram();
gl.attachShader(program, fragShader);
gl.attachShader(program, vertShader);
gl.linkProgram(program);
check$1.<span class="apidocCodeKeywordSpan">linkError</span>(
  gl,
  program,
  stringStore.str(desc.fragId),
  stringStore.str(desc.vertId),
  command);

// -------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.nni" id="apidoc.element.regl.check.nni">
        function <span class="apidocSignatureSpan">regl.check.</span>nni
        <span class="apidocSignatureSpan">(value, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkNonNegativeInt(value, message) {
  if (!((value &#x3e;= 0) &#x26;&#x26;
        ((value | 0) === value))) {
    raise(&#x27;invalid parameter type, (&#x27; + value + &#x27;)&#x27; + encolon(message) +
          &#x27;. must be a nonnegative integer&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (&#x27;dimension&#x27; in options) {
    check$1.type(options.dimension, &#x27;number&#x27;, &#x27;invalid dimension&#x27;);
    dimension = options.dimension | 0;
  }

  if (&#x27;length&#x27; in options) {
    check$1.<span class="apidocCodeKeywordSpan">nni</span>(byteLength, &#x27;buffer length must be a nonnegative integer&#x27;);
    byteLength = options.length | 0;
  }
}

buffer.bind();
if (!data) {
  gl.bufferData(buffer.type, byteLength, usage);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.oneOf" id="apidoc.element.regl.check.oneOf">
        function <span class="apidocSignatureSpan">regl.check.</span>oneOf
        <span class="apidocSignatureSpan">(value, list, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkOneOf(value, list, message) {
  if (list.indexOf(value) &#x3c; 0) {
    raise(&#x27;invalid value&#x27; + encolon(message) + &#x27;. must be one of: &#x27; + list)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (&#x27;flipY&#x27; in options) {
  check$1.type(options.flipY, &#x27;boolean&#x27;,
    &#x27;invalid texture flip&#x27;);
  flags.flipY = options.flipY;
}

if (&#x27;alignment&#x27; in options) {
  check$1.<span class="apidocCodeKeywordSpan">oneOf</span>(options.alignment, [1, 2, 4, 8],
    &#x27;invalid texture unpack alignment&#x27;);
  flags.unpackAlignment = options.alignment;
}

if (&#x27;colorSpace&#x27; in options) {
  check$1.parameter(options.colorSpace, colorSpace,
    &#x27;invalid colorSpace&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.optional" id="apidoc.element.regl.check.optional">
        function <span class="apidocSignatureSpan">regl.check.</span>optional
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkOptional(block) {
  block()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  blendFuncs: blendFuncs,
  blendEquations: blendEquations,
  stencilOps: stencilOps,
  glTypes: glTypes,
  orientationType: orientationType
};

check$1.<span class="apidocCodeKeywordSpan">optional</span>(function () {
  sharedState.isArrayLike = isArrayLike;
});

if (extDrawBuffers) {
  sharedConstants.backBuffer = [GL_BACK];
  sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
    if (i === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.parameter" id="apidoc.element.regl.check.parameter">
        function <span class="apidocSignatureSpan">regl.check.</span>parameter
        <span class="apidocSignatureSpan">(param, possibilities, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkParameter(param, possibilities, message) {
  if (!(param in possibilities)) {
    raise(&#x27;unknown parameter (&#x27; + param + &#x27;)&#x27; + encolon(message) +
          &#x27;. possible values: &#x27; + Object.keys(possibilities).join())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    isTypedArray(data) ||
    isNDArrayLike(data),
    &#x27;invalid data for buffer&#x27;);
  data = options.data;
}

if (&#x27;usage&#x27; in options) {
  check$1.<span class="apidocCodeKeywordSpan">parameter</span>(options.usage, usageTypes, &#x27;invalid buffer usage&#x27;);
  usage = usageTypes[options.usage];
}

if (&#x27;type&#x27; in options) {
  check$1.parameter(options.type, glTypes, &#x27;invalid buffer type&#x27;);
  dtype = glTypes[options.type];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.raise" id="apidoc.element.regl.check.raise">
        function <span class="apidocSignatureSpan">regl.check.</span>raise
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function raise(message) {
  var error = new Error(&#x27;(regl) &#x27; + message)
  console.error(error)
  throw error
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return EMPTY_ARRAY
}

function REGLCommand (args, body) {
  var i
  if (contextLost) {
    check.<span class="apidocCodeKeywordSpan">raise</span>(&#x27;context lost&#x27;)
  }
  if (typeof args === &#x27;function&#x27;) {
    return scope.call(this, null, args, 0)
  } else if (typeof body === &#x27;function&#x27;) {
    if (typeof args === &#x27;number&#x27;) {
      for (i = 0; i &#x3c; args; ++i) {
        scope.call(this, null, body, i)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.saveCommandRef" id="apidoc.element.regl.check.saveCommandRef">
        function <span class="apidocSignatureSpan">regl.check.</span>saveCommandRef
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveCommandRef(object) {
  object._commandRef = guessCommand()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.saveDrawInfo" id="apidoc.element.regl.check.saveDrawInfo">
        function <span class="apidocSignatureSpan">regl.check.</span>saveDrawInfo
        <span class="apidocSignatureSpan">(opts, uniforms, attributes, stringStore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    &#x27;count&#x27; in opts.static ||
    &#x27;count&#x27; in opts.dynamic ||
    &#x27;elements&#x27; in opts.static ||
    &#x27;elements&#x27; in opts.dynamic)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.shaderError" id="apidoc.element.regl.check.shaderError">
        function <span class="apidocSignatureSpan">regl.check.</span>shaderError
        <span class="apidocSignatureSpan">(gl, shader, source, type, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkShaderError(gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? &#x27;fragment&#x27; : &#x27;vertex&#x27;
    checkCommandType(source, &#x27;string&#x27;, typeName + &#x27; shader source must be a string&#x27;, command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = [&#x27;&#x27;]
      var styles = [&#x27;&#x27;]

      function push (str, style) {
        strings.push(str)
        styles.push(style || &#x27;&#x27;)
      }

      push(&#x27;file number &#x27; + fileNumber + &#x27;: &#x27; + file.name + &#x27;\n&#x27;, &#x27;color:red;text-decoration:underline;font-weight:bold&#x27;)

      file.lines.forEach(function (line) {
        if (line.errors.length &#x3e; 0) {
          push(leftPad(line.number, 4) + &#x27;|  &#x27;, &#x27;background-color:yellow; font-weight:bold&#x27;)
          push(line.line + &#x27;\n&#x27;, &#x27;color:red; background-color:yellow; font-weight:bold&#x27;)

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*\&#x27;(.*)\&#x27;\s*\:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case &#x27;assign&#x27;:
                  tokenPat = &#x27;=&#x27;
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad(&#x27;| &#x27;, 6))
            push(leftPad(&#x27;^^^&#x27;, offset + 3) + &#x27;\n&#x27;, &#x27;font-weight:bold&#x27;)
            push(leftPad(&#x27;| &#x27;, 6))
            push(message + &#x27;\n&#x27;, &#x27;font-weight:bold&#x27;)
          })
          push(leftPad(&#x27;| &#x27;, 6) + &#x27;\n&#x27;)
        } else {
          push(leftPad(line.number, 4) + &#x27;|  &#x27;)
          push(line.line + &#x27;\n&#x27;, &#x27;color:red&#x27;)
        }
      })
      if (typeof document !== &#x27;undefined&#x27;) {
        styles[0] = strings.join(&#x27;%c&#x27;)
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(&#x27;&#x27;))
      }
    })

    check.raise(&#x27;Error compiling &#x27; + typeName + &#x27; shader, &#x27; + files[0].name)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var shader = cache[id];

  if (!shader) {
    var source = stringStore.str(id);
    shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    check$1.<span class="apidocCodeKeywordSpan">shaderError</span>(gl, shader, source, type, command);
    cache[id] = shader;
  }

  return shader
}

// ===================================================
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.texture2D" id="apidoc.element.regl.check.texture2D">
        function <span class="apidocSignatureSpan">regl.check.</span>texture2D
        <span class="apidocSignatureSpan">(info, mipData, limits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkTexture2D(info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w &#x3e; 0 &#x26;&#x26; w &#x3c;= limits.maxTextureSize &#x26;&#x26;
        h &#x3e; 0 &#x26;&#x26; h &#x3c;= limits.maxTextureSize,
        &#x27;invalid texture shape&#x27;)

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) &#x26;&#x26; isPow2(h),
      &#x27;incompatible wrap mode for texture, both width and height must be power of 2&#x27;)
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 &#x26;&#x26; h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &#x26;&#x26;
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &#x26;&#x26;
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &#x26;&#x26;
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        &#x27;min filter requires mipmap&#x27;)
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) &#x26;&#x26; isPow2(h),
      &#x27;texture must be a square power of 2 to support mipmapping&#x27;)
    check(mipData.mipmask === (w &#x3c;&#x3c; 1) - 1,
      &#x27;missing or incomplete mipmap data&#x27;)
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf(&#x27;oes_texture_float_linear&#x27;) &#x3c; 0) {
      check(info.minFilter === GL_NEAREST &#x26;&#x26; info.magFilter === GL_NEAREST,
        &#x27;filter not supported, must enable oes_texture_float_linear&#x27;)
    }
    check(!info.genMipmaps,
      &#x27;mipmap generation not supported with float textures&#x27;)
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i &#x3c; 16; ++i) {
    if (mipimages[i]) {
      var mw = w &#x3e;&#x3e; i
      var mh = h &#x3e;&#x3e; i
      check(mipData.mipmask &#x26; (1 &#x3c;&#x3c; i), &#x27;missing mipmap data&#x27;)

      var img = mipimages[i]

      check(
        img.width === mw &#x26;&#x26;
        img.height === mh,
        &#x27;invalid shape for mip images&#x27;)

      check(
        img.format === mipData.format &#x26;&#x26;
        img.internalformat === mipData.internalformat &#x26;&#x26;
        img.type === mipData.type,
        &#x27;incompatible type for mip image&#x27;)

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          &#x27;invalid data for image, buffer size is inconsistent with image format&#x27;)
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask &#x26; (1 &#x3c;&#x3c; i)) === 0, &#x27;extra mipmap data&#x27;)
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      &#x27;mipmap generation for compressed images not supported&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (texInfo.genMipmaps) {
  mipData.mipmask = (mipData.width &#x3c;&#x3c; 1) - 1;
}
texture.mipmask = mipData.mipmask;

copyFlags(texture, mipData);

check$1.<span class="apidocCodeKeywordSpan">texture2D</span>(texInfo, mipData, limits);
texture.internalformat = mipData.internalformat;

reglTexture2D.width = mipData.width;
reglTexture2D.height = mipData.height;

tempBind(texture);
setMipMap(mipData, GL_TEXTURE_2D);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.textureCube" id="apidoc.element.regl.check.textureCube">
        function <span class="apidocSignatureSpan">regl.check.</span>textureCube
        <span class="apidocSignatureSpan">(texture, info, faces, limits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkTextureCube(texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w &#x3e; 0 &#x26;&#x26; w &#x3c;= limits.maxTextureSize &#x26;&#x26; h &#x3e; 0 &#x26;&#x26; h &#x3c;= limits.maxTextureSize,
    &#x27;invalid texture shape&#x27;)
  check(
    w === h,
    &#x27;cube map must be square&#x27;)
  check(
    info.wrapS === GL_CLAMP_TO_EDGE &#x26;&#x26; info.wrapT === GL_CLAMP_TO_EDGE,
    &#x27;wrap mode not supported by cube map&#x27;)

  for (var i = 0; i &#x3c; faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w &#x26;&#x26; face.height === h,
      &#x27;inconsistent cube map face shape&#x27;)

    if (info.genMipmaps) {
      check(!face.compressed,
        &#x27;can not generate mipmap for compressed textures&#x27;)
      check(face.mipmask === 1,
        &#x27;can not specify mipmaps and generate mipmaps&#x27;)
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j &#x3c; 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w &#x3e;&#x3e; j
        var mh = h &#x3e;&#x3e; j
        check(face.mipmask &#x26; (1 &#x3c;&#x3c; j), &#x27;missing mipmap data&#x27;)
        check(
          img.width === mw &#x26;&#x26;
          img.height === mh,
          &#x27;invalid shape for mip images&#x27;)
        check(
          img.format === texture.format &#x26;&#x26;
          img.internalformat === texture.internalformat &#x26;&#x26;
          img.type === texture.type,
          &#x27;incompatible type for mip image&#x27;)

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
            &#x27;invalid data for image, buffer size is inconsistent with image format&#x27;)
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
copyFlags(texture, faces[0]);
if (texInfo.genMipmaps) {
  texture.mipmask = (faces[0].width &#x3c;&#x3c; 1) - 1;
} else {
  texture.mipmask = faces[0].mipmask;
}

check$1.<span class="apidocCodeKeywordSpan">textureCube</span>(texture, texInfo, faces, limits);
texture.internalformat = faces[0].internalformat;

reglTextureCube.width = faces[0].width;
reglTextureCube.height = faces[0].height;

tempBind(texture);
for (i = 0; i &#x3c; 6; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.type" id="apidoc.element.regl.check.type">
        function <span class="apidocSignatureSpan">regl.check.</span>type
        <span class="apidocSignatureSpan">(value, type, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkTypeOf(value, type, message) {
  if (typeof value !== type) {
    raise(
      &#x27;invalid parameter type&#x27; + encolon(message) +
      &#x27;. expected &#x27; + type + &#x27;, got &#x27; + (typeof value))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
destroyCallbacks.forEach(function (cb) {
  cb()
})
  }

  function compileProcedure (options) {
check(!!options, &#x27;invalid args to regl({...})&#x27;)
check.<span class="apidocCodeKeywordSpan">type</span>(options, &#x27;object&#x27;, &#x27;invalid args to regl({...})&#x27;)

function flattenNestedOptions (options) {
  var result = extend({}, options)
  delete result.uniforms
  delete result.attributes
  delete result.context
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.dynamic" id="apidoc.module.regl.dynamic">module regl.dynamic</a></h1>


    <h2>
        <a href="#apidoc.element.regl.dynamic.DynamicVariable" id="apidoc.element.regl.dynamic.DynamicVariable">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>DynamicVariable
        <span class="apidocSignatureSpan">(type, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DynamicVariable(type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return
    }
    var ref = env.invoke(block, value);
    block(objectRef, &#x27;.&#x27;, key, &#x27;=&#x27;, ref, &#x27;;&#x27;);
  });
}

options.dynamic[name] = new dynamic.<span class="apidocCodeKeywordSpan">DynamicVariable</span>(DYN_THUNK, {
  thisDep: thisDep,
  contextDep: contextDep,
  propDep: propDep,
  ref: objectRef,
  append: appendBlock
});
delete options.static[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.accessor" id="apidoc.element.regl.dynamic.accessor">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>accessor
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toAccessorString(str) {
  return &#x27;[&#x27; + splitParts(str).join(&#x27;][&#x27;) + &#x27;]&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.define" id="apidoc.element.regl.dynamic.define">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>define
        <span class="apidocSignatureSpan">(type, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineDynamic(type, data) {
  return new DynamicVariable(type, toAccessorString(data + &#x27;&#x27;))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.isDynamic" id="apidoc.element.regl.dynamic.isDynamic">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>isDynamic
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDynamic(x) {
  return (typeof x === &#x27;function&#x27; &#x26;&#x26; !x._reglType) ||
         x instanceof DynamicVariable
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function separateDynamic (object) {
  var staticItems = {}
  var dynamicItems = {}
  Object.keys(object).forEach(function (option) {
    var value = object[option]
    if (dynamic.<span class="apidocCodeKeywordSpan">isDynamic</span>(value)) {
      dynamicItems[option] = dynamic.unbox(value, option)
    } else {
      staticItems[option] = value
    }
  })
  return {
    dynamic: dynamicItems,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.unbox" id="apidoc.element.regl.dynamic.unbox">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>unbox
        <span class="apidocSignatureSpan">(x, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unbox(x, path) {
  if (typeof x === &#x27;function&#x27;) {
    return new DynamicVariable(DYN_FUNC, x)
  }
  return x
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    function separateDynamic (object) {
var staticItems = {}
var dynamicItems = {}
Object.keys(object).forEach(function (option) {
  var value = object[option]
  if (dynamic.isDynamic(value)) {
    dynamicItems[option] = dynamic.<span class="apidocCodeKeywordSpan">unbox</span>(value, option)
  } else {
    staticItems[option] = value
  }
})
return {
  dynamic: dynamicItems,
  static: staticItems
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.flatten" id="apidoc.module.regl.flatten">module regl.flatten</a></h1>


    <h2>
        <a href="#apidoc.element.regl.flatten.flatten" id="apidoc.element.regl.flatten.flatten">
        function <span class="apidocSignatureSpan">regl.</span>flatten
        <span class="apidocSignatureSpan">(array, shape, type, out_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenArray(array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i &#x3c; shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
var arrayShape = flattenUtils.shape(data);
var n = 1;
for (var dd = 0; dd &#x3c; arrayShape.length; ++dd) {
  n *= arrayShape[dd];
}
var allocData = preConvert(image, n);
flattenUtils.<span class="apidocCodeKeywordSpan">flatten</span>(data, arrayShape, &#x27;&#x27;, allocData);
postConvert(image, allocData);
image.alignment = 1;
image.width = w;
image.height = h;
image.channels = c;
image.format = image.internalformat = CHANNELS_FORMAT[c];
image.needsFree = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.flatten.shape" id="apidoc.element.regl.flatten.shape">
        function <span class="apidocSignatureSpan">regl.flatten.</span>shape
        <span class="apidocSignatureSpan">(array_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayShape(array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var h = image.height || data.length;
var c = image.channels;
if (isArrayLike(data[0][0])) {
  c = c || data[0][0].length;
} else {
  c = c || 1;
}
var arrayShape = flattenUtils.<span class="apidocCodeKeywordSpan">shape</span>(data);
var n = 1;
for (var dd = 0; dd &#x3c; arrayShape.length; ++dd) {
  n *= arrayShape[dd];
}
var allocData = preConvert(image, n);
flattenUtils.flatten(data, arrayShape, &#x27;&#x27;, allocData);
postConvert(image, allocData);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.pool" id="apidoc.module.regl.pool">module regl.pool</a></h1>


    <h2>
        <a href="#apidoc.element.regl.pool.alloc" id="apidoc.element.regl.pool.alloc">
        function <span class="apidocSignatureSpan">regl.pool.</span>alloc
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function alloc(n) {
  var sz = nextPow16(n)
  var bin = bufferPool[log2(sz) &#x3e;&#x3e; 2]
  if (bin.length &#x3e; 0) {
    return bin.pop()
  }
  return new ArrayBuffer(sz)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.pool.allocType" id="apidoc.element.regl.pool.allocType">
        function <span class="apidocSignatureSpan">regl.pool.</span>allocType
        <span class="apidocSignatureSpan">(type, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allocType(type, n) {
  var result = null
  switch (type) {
    case GL_BYTE:
      result = new Int8Array(alloc(n), 0, n)
      break
    case GL_UNSIGNED_BYTE:
      result = new Uint8Array(alloc(n), 0, n)
      break
    case GL_SHORT:
      result = new Int16Array(alloc(2 * n), 0, n)
      break
    case GL_UNSIGNED_SHORT:
      result = new Uint16Array(alloc(2 * n), 0, n)
      break
    case GL_INT:
      result = new Int32Array(alloc(4 * n), 0, n)
      break
    case GL_UNSIGNED_INT:
      result = new Uint32Array(alloc(4 * n), 0, n)
      break
    case GL_FLOAT:
      result = new Float32Array(alloc(4 * n), 0, n)
      break
    default:
      return null
  }
  if (result.length !== n) {
    return result.subarray(0, n)
  }
  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (shape.length) {
  for (var i = 0; i &#x3c; shape.length; ++i) {
    sz *= shape[i];
  }
} else {
  sz = 0;
}
var out = out_ || pool.<span class="apidocCodeKeywordSpan">allocType</span>(type, sz);
switch (shape.length) {
  case 0:
    break
  case 1:
    flatten1D(array, shape[0], out);
    break
  case 2:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.pool.free" id="apidoc.element.regl.pool.free">
        function <span class="apidocSignatureSpan">regl.pool.</span>free
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function free(buf) {
  bufferPool[log2(buf.byteLength) &#x3e;&#x3e; 2].push(buf)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.pool.freeType" id="apidoc.element.regl.pool.freeType">
        function <span class="apidocSignatureSpan">regl.pool.</span>freeType
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function freeType(array) {
  free(array.buffer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  buffer.dimension = dim;
  flatData = arrayFlatten(data, shape, buffer.dtype);
  initBufferFromTypedArray(buffer, flatData, usage);
  if (persist) {
    buffer.persistentData = flatData;
  } else {
    pool.<span class="apidocCodeKeywordSpan">freeType</span>(flatData);
  }
} else if (typeof data[0] === &#x27;number&#x27;) {
  buffer.dimension = dimension;
  var typedData = pool.allocType(buffer.dtype, data.length);
  copyArray(typedData, data);
  initBufferFromTypedArray(buffer, typedData, usage);
  if (persist) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.raf" id="apidoc.module.regl.raf">module regl.raf</a></h1>


    <h2>
        <a href="#apidoc.element.regl.raf.cancel" id="apidoc.element.regl.raf.cancel">
        function <span class="apidocSignatureSpan">regl.raf.</span>cancel
        <span class="apidocSignatureSpan">(timer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cancel = function (timer) {
  if (timer &#x26;&#x26; (timer[kOnTimeout] || timer._onTimeout)) {
    timer[kOnTimeout] = timer._onTimeout = null;
    if (timer instanceof Timeout) {
      timer.close(); // for after === 0
    } else {
      unenroll(timer);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // context is the default state of the regl context variables

  // ...
})

// When we are done, we can unsubscribe by calling cancel on the callback
tick.<span class="apidocCodeKeywordSpan">cancel</span>()
```

It is possible to manage framecallbacks manually, however before any loop it is essential to call `regl.poll()` which updates all
 timers and viewports.

* * *

### Extensions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.raf.next" id="apidoc.element.regl.raf.next">
        function <span class="apidocSignatureSpan">regl.raf.</span>next
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (cb) { return setTimeout(cb, 16) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    timer.update()
  }
  activeRAF = null
  return
}

// schedule next animation frame
activeRAF = raf.<span class="apidocCodeKeywordSpan">next</span>(handleRAF)

// poll for changes
poll()

// fire a callback for all pending rafs
for (var i = rafCallbacks.length - 1; i &#x3e;= 0; --i) {
  var cb = rafCallbacks[i]
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
