<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://mikolalysenko.github.io/regl">regl (v1.3.0)</a>
</h1>
<h4>regl is a fast functional WebGL framework.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl">module regl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.regl">
            function <span class="apidocSignatureSpan"></span>regl
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check">
            function <span class="apidocSignatureSpan">regl.</span>check
            <span class="apidocSignatureSpan">(pred, message)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>dynamic</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>flatten</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>pool</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">regl.</span>raf</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.check">module regl.check</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.check">
            function <span class="apidocSignatureSpan">regl.</span>check
            <span class="apidocSignatureSpan">(pred, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.callSite">
            function <span class="apidocSignatureSpan">regl.check.</span>callSite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.command">
            function <span class="apidocSignatureSpan">regl.check.</span>command
            <span class="apidocSignatureSpan">(pred, message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.commandParameter">
            function <span class="apidocSignatureSpan">regl.check.</span>commandParameter
            <span class="apidocSignatureSpan">(param, possibilities, message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.commandRaise">
            function <span class="apidocSignatureSpan">regl.check.</span>commandRaise
            <span class="apidocSignatureSpan">(message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.commandType">
            function <span class="apidocSignatureSpan">regl.check.</span>commandType
            <span class="apidocSignatureSpan">(value, type, message, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.constructor">
            function <span class="apidocSignatureSpan">regl.check.</span>constructor
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.framebufferFormat">
            function <span class="apidocSignatureSpan">regl.check.</span>framebufferFormat
            <span class="apidocSignatureSpan">(attachment, texFormats, rbFormats)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.guessCommand">
            function <span class="apidocSignatureSpan">regl.check.</span>guessCommand
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.isTypedArray">
            function <span class="apidocSignatureSpan">regl.check.</span>isTypedArray
            <span class="apidocSignatureSpan">(data, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.linkError">
            function <span class="apidocSignatureSpan">regl.check.</span>linkError
            <span class="apidocSignatureSpan">(gl, program, fragShader, vertShader, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.nni">
            function <span class="apidocSignatureSpan">regl.check.</span>nni
            <span class="apidocSignatureSpan">(value, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.oneOf">
            function <span class="apidocSignatureSpan">regl.check.</span>oneOf
            <span class="apidocSignatureSpan">(value, list, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.optional">
            function <span class="apidocSignatureSpan">regl.check.</span>optional
            <span class="apidocSignatureSpan">(block)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.parameter">
            function <span class="apidocSignatureSpan">regl.check.</span>parameter
            <span class="apidocSignatureSpan">(param, possibilities, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.raise">
            function <span class="apidocSignatureSpan">regl.check.</span>raise
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.saveCommandRef">
            function <span class="apidocSignatureSpan">regl.check.</span>saveCommandRef
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.saveDrawInfo">
            function <span class="apidocSignatureSpan">regl.check.</span>saveDrawInfo
            <span class="apidocSignatureSpan">(opts, uniforms, attributes, stringStore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.shaderError">
            function <span class="apidocSignatureSpan">regl.check.</span>shaderError
            <span class="apidocSignatureSpan">(gl, shader, source, type, command)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.texture2D">
            function <span class="apidocSignatureSpan">regl.check.</span>texture2D
            <span class="apidocSignatureSpan">(info, mipData, limits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.textureCube">
            function <span class="apidocSignatureSpan">regl.check.</span>textureCube
            <span class="apidocSignatureSpan">(texture, info, faces, limits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.check.type">
            function <span class="apidocSignatureSpan">regl.check.</span>type
            <span class="apidocSignatureSpan">(value, type, message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.dynamic">module regl.dynamic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.DynamicVariable">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>DynamicVariable
            <span class="apidocSignatureSpan">(type, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.accessor">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>accessor
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.define">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>define
            <span class="apidocSignatureSpan">(type, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.isDynamic">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>isDynamic
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.dynamic.unbox">
            function <span class="apidocSignatureSpan">regl.dynamic.</span>unbox
            <span class="apidocSignatureSpan">(x, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.flatten">module regl.flatten</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.flatten.flatten">
            function <span class="apidocSignatureSpan">regl.</span>flatten
            <span class="apidocSignatureSpan">(array, shape, type, out_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.flatten.shape">
            function <span class="apidocSignatureSpan">regl.flatten.</span>shape
            <span class="apidocSignatureSpan">(array_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.pool">module regl.pool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.alloc">
            function <span class="apidocSignatureSpan">regl.pool.</span>alloc
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.allocType">
            function <span class="apidocSignatureSpan">regl.pool.</span>allocType
            <span class="apidocSignatureSpan">(type, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.free">
            function <span class="apidocSignatureSpan">regl.pool.</span>free
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.pool.freeType">
            function <span class="apidocSignatureSpan">regl.pool.</span>freeType
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.regl.raf">module regl.raf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.raf.cancel">
            function <span class="apidocSignatureSpan">regl.raf.</span>cancel
            <span class="apidocSignatureSpan">(timer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.regl.raf.next">
            function <span class="apidocSignatureSpan">regl.raf.</span>next
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl" id="apidoc.module.regl">module regl</a></h1>


    <h2>
        <a href="#apidoc.element.regl.regl" id="apidoc.element.regl.regl">
        function <span class="apidocSignatureSpan"></span>regl
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapREGL(args) {
  var config = parseArgs(args);
  if (!config) {
    return null
  }

  var gl = config.gl;
  var glAttributes = gl.getContextAttributes();
  var contextLost = gl.isContextLost();

  var extensionState = createExtensionCache(gl, config);
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore();
  var stats$$1 = stats();
  var extensions = extensionState.extensions;
  var timer = createTimer(gl, extensions);

  var START_TIME = clock();
  var WIDTH = gl.drawingBufferWidth;
  var HEIGHT = gl.drawingBufferHeight;

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  };
  var uniformState = {};
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  };

  var limits = wrapLimits(gl, extensions);
  var bufferState = wrapBufferState(gl, stats$$1, config);
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    bufferState,
    stringStore);
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll(); },
    contextState,
    stats$$1,
    config);
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1);
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config);
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions);

  var nextState = core.next;
  var canvas = gl.canvas;

  var rafCallbacks = [];
  var lossCallbacks = [];
  var restoreCallbacks = [];
  var destroyCallbacks = [config.onDestroy];

  var activeRAF = null;
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update();
      }
      activeRAF = null;
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF);

    // poll for changes
    poll();

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i &gt;= 0; --i) {
      var cb = rafCallbacks[i];
      if (cb) {
        cb(contextState, null, 0);
      }
    }

    // flush all pending webgl calls
    gl.flush();

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update();
    }
  }

  function startRAF () {
    if (!activeRAF &amp;&amp; rafCallbacks.length &gt; 0) {
      activeRAF = raf.next(handleRAF);
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF);
      activeRAF = null;
    }
  }

  function handleContextLoss (event) {
    event.preventDefault();

    // set context lost flag
    contextLost = true;

    // pause request animation frame
    stopRAF();

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb();
    });
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError();

    // clear context lost flag
    contextLost = false;

    // refresh state
    extensionState.restore();
    shaderState.restore();
    bufferState.restore();
    textureState.restore();
    renderbufferState.restore();
    framebufferState.restore();
    if (timer) {
      timer.restore();
    }

    // refresh state
    core.procs.refresh();

    // restart RAF
    startRAF();

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb();
    });
  }

  if (canvas) {
    canvas.addEventListener(CO ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check" id="apidoc.element.regl.check">
        function <span class="apidocSignatureSpan">regl.</span>check
        <span class="apidocSignatureSpan">(pred, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check(pred, message) {
  if (!pred) {
    raise(message)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.check" id="apidoc.module.regl.check">module regl.check</a></h1>


    <h2>
        <a href="#apidoc.element.regl.check.check" id="apidoc.element.regl.check.check">
        function <span class="apidocSignatureSpan">regl.</span>check
        <span class="apidocSignatureSpan">(pred, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check(pred, message) {
  if (!pred) {
    raise(message)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.callSite" id="apidoc.element.regl.check.callSite">
        function <span class="apidocSignatureSpan">regl.check.</span>callSite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function guessCallSite() {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.command" id="apidoc.element.regl.check.command">
        function <span class="apidocSignatureSpan">regl.check.</span>command
        <span class="apidocSignatureSpan">(pred, message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkCommand(pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var staticOptions = options.static
var dynamicOptions = options.dynamic

if (S_FRAMEBUFFER in staticOptions) {
  var framebuffer = staticOptions[S_FRAMEBUFFER]
  if (framebuffer) {
    framebuffer = framebufferState.getFramebuffer(framebuffer)
    check.<span class="apidocCodeKeywordSpan">command</span>(framebuffer, 'invalid framebuffer object')
    return createStaticDecl(function (env, block) {
      var FRAMEBUFFER = env.link(framebuffer)
      var shared = env.shared
      block.set(
        shared.framebuffer,
        '.next',
        FRAMEBUFFER)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.commandParameter" id="apidoc.element.regl.check.commandParameter">
        function <span class="apidocSignatureSpan">regl.check.</span>commandParameter
        <span class="apidocSignatureSpan">(param, possibilities, message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkParameterCommand(param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var elements = parseElements()

function parsePrimitive () {
  if (S_PRIMITIVE in staticOptions) {
    var primitive = staticOptions[S_PRIMITIVE]
    check.<span class="apidocCodeKeywordSpan">commandParameter</span>(primitive, primTypes, 'invalid primitve', env.commandStr
)
    return createStaticDecl(function (env, scope) {
      return primTypes[primitive]
    })
  } else if (S_PRIMITIVE in dynamicOptions) {
    var dynPrimitive = dynamicOptions[S_PRIMITIVE]
    return createDynamicDecl(dynPrimitive, function (env, scope) {
      var PRIM_TYPES = env.constants.primTypes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.commandRaise" id="apidoc.element.regl.check.commandRaise">
        function <span class="apidocSignatureSpan">regl.check.</span>commandRaise
        <span class="apidocSignatureSpan">(message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function commandRaise(message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
check.optional(function () {
  env.CHECK = link(check)
  env.commandStr = check.guessCommand()
  env.command = link(env.commandStr)
  env.assert = function (block, pred, message) {
    block(
      'if(!(', pred, '))',
      this.CHECK, '.<span class="apidocCodeKeywordSpan">commandRaise</span>(', link(message), ',', this.command
, ');')
  }

  sharedConstants.invalidBlendCombinations = invalidBlendCombinations
})

// Copy GL state variables over
var nextVars = env.next = {}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.commandType" id="apidoc.element.regl.check.commandType">
        function <span class="apidocSignatureSpan">regl.check.</span>commandType
        <span class="apidocSignatureSpan">(value, type, message, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkCommandType(value, type, message, command) {
  if (typeof value !== type) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
var box = staticOptions[param]
check.<span class="apidocCodeKeywordSpan">commandType</span>(box, 'object', 'invalid ' + param, env.commandStr
)

var isStatic = true
var x = box.x | 0
var y = box.y | 0
var w, h
if ('width' in box) {
  w = box.width | 0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.constructor" id="apidoc.element.regl.check.constructor">
        function <span class="apidocSignatureSpan">regl.check.</span>constructor
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkConstructor(obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) &lt; 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else if (typeof args === 'object') {
if (isHTMLElement(args)) {
  element = args
} else if (isWebGLContext(args)) {
  gl = args
  canvas = gl.canvas
} else {
  check.<span class="apidocCodeKeywordSpan">constructor</span>(args)
  if ('gl' in args) {
    gl = args.gl
  } else if ('canvas' in args) {
    canvas = getElement(args.canvas)
  } else if ('container' in args) {
    container = getElement(args.container)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.framebufferFormat" id="apidoc.element.regl.check.framebufferFormat">
        function <span class="apidocSignatureSpan">regl.check.</span>framebufferFormat
        <span class="apidocSignatureSpan">(attachment, texFormats, rbFormats)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkFramebufferFormat(attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.guessCommand" id="apidoc.element.regl.check.guessCommand">
        function <span class="apidocSignatureSpan">regl.check.</span>guessCommand
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function guessCommand() {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Object.keys(sharedState).forEach(function (prop) {
  shared[prop] = global.def(SHARED, '.', prop)
})

// Inject runtime assertion stuff for debug builds
check.optional(function () {
  env.CHECK = link(check)
  env.commandStr = check.<span class="apidocCodeKeywordSpan">guessCommand</span>()
  env.command = link(env.commandStr)
  env.assert = function (block, pred, message) {
    block(
      'if(!(', pred, '))',
      this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.isTypedArray" id="apidoc.element.regl.check.isTypedArray">
        function <span class="apidocSignatureSpan">regl.check.</span>isTypedArray
        <span class="apidocSignatureSpan">(data, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkIsTypedArray(data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    data = new Uint8Array(size)
  } else if (type === GL_FLOAT) {
    data = data || new Float32Array(size)
  }
}

// Type check
check.<span class="apidocCodeKeywordSpan">isTypedArray</span>(data, 'data buffer for regl.read() must be a typedarray')
check(data.byteLength &gt;= size, 'data buffer for regl.read() too small')

// Run read pixels
gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
gl.readPixels(x, y, width, height, GL_RGBA,
              type,
              data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.linkError" id="apidoc.element.regl.check.linkError">
        function <span class="apidocSignatureSpan">regl.check.</span>linkError
        <span class="apidocSignatureSpan">(gl, program, fragShader, vertShader, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkLinkError(gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + '\n%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + '\n' + errLog)
    }
    check.raise(header)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

var program = desc.program = gl.createProgram()
gl.attachShader(program, fragShader)
gl.attachShader(program, vertShader)
gl.linkProgram(program)
check.<span class="apidocCodeKeywordSpan">linkError</span>(
  gl,
  program,
  stringStore.str(desc.fragId),
  stringStore.str(desc.vertId),
  command)

// -------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.nni" id="apidoc.element.regl.check.nni">
        function <span class="apidocSignatureSpan">regl.check.</span>nni
        <span class="apidocSignatureSpan">(value, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkNonNegativeInt(value, message) {
  if (!((value &gt;= 0) &amp;&amp;
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if ('dimension' in options) {
    check.type(options.dimension, 'number', 'invalid dimension')
    dimension = options.dimension | 0
  }

  if ('length' in options) {
    check.<span class="apidocCodeKeywordSpan">nni</span>(byteLength, 'buffer length must be a nonnegative integer')
    byteLength = options.length | 0
  }
}

buffer.bind()
if (!data) {
  gl.bufferData(buffer.type, byteLength, usage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.oneOf" id="apidoc.element.regl.check.oneOf">
        function <span class="apidocSignatureSpan">regl.check.</span>oneOf
        <span class="apidocSignatureSpan">(value, list, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkOneOf(value, list, message) {
  if (list.indexOf(value) &lt; 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    check(extensions.oes_texture_float ||
      !(colorType === 'float' || colorType === 'float32'),
      'you must enable OES_texture_float in order to use floating point framebuffer objects')
    check(extensions.oes_texture_half_float ||
      !(colorType === 'half float' || colorType === 'float16'),
      'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
  }
  check.<span class="apidocCodeKeywordSpan">oneOf</span>(colorType, colorTypes, 'invalid color type')
}

if ('colorFormat' in options) {
  colorFormat = options.colorFormat
  if (colorTextureFormats.indexOf(colorFormat) &gt;= 0) {
    colorTexture = true
  } else if (colorRenderbufferFormats.indexOf(colorFormat) &gt;= 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.optional" id="apidoc.element.regl.check.optional">
        function <span class="apidocSignatureSpan">regl.check.</span>optional
        <span class="apidocSignatureSpan">(block)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkOptional(block) {
  block()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  blendFuncs: blendFuncs,
  blendEquations: blendEquations,
  stencilOps: stencilOps,
  glTypes: glTypes,
  orientationType: orientationType
}

check.<span class="apidocCodeKeywordSpan">optional</span>(function () {
  sharedState.isArrayLike = isArrayLike
})

if (extDrawBuffers) {
  sharedConstants.backBuffer = [GL_BACK]
  sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
    if (i === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.parameter" id="apidoc.element.regl.check.parameter">
        function <span class="apidocSignatureSpan">regl.check.</span>parameter
        <span class="apidocSignatureSpan">(param, possibilities, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkParameter(param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    isTypedArray(data) ||
    isNDArrayLike(data),
    'invalid data for buffer')
  data = options.data
}

if ('usage' in options) {
  check.<span class="apidocCodeKeywordSpan">parameter</span>(options.usage, usageTypes, 'invalid buffer usage')
  usage = usageTypes[options.usage]
}

if ('type' in options) {
  check.parameter(options.type, bufferTypes, 'invalid buffer type')
  dtype = bufferTypes[options.type]
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.raise" id="apidoc.element.regl.check.raise">
        function <span class="apidocSignatureSpan">regl.check.</span>raise
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function raise(message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return EMPTY_ARRAY
}

function REGLCommand (args, body) {
  var i
  if (contextLost) {
    check.<span class="apidocCodeKeywordSpan">raise</span>('context lost')
  }
  if (typeof args === 'function') {
    return scope.call(this, null, args, 0)
  } else if (typeof body === 'function') {
    if (typeof args === 'number') {
      for (i = 0; i &lt; args; ++i) {
        scope.call(this, null, body, i)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.saveCommandRef" id="apidoc.element.regl.check.saveCommandRef">
        function <span class="apidocSignatureSpan">regl.check.</span>saveCommandRef
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveCommandRef(object) {
  object._commandRef = guessCommand()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.saveDrawInfo" id="apidoc.element.regl.check.saveDrawInfo">
        function <span class="apidocSignatureSpan">regl.check.</span>saveDrawInfo
        <span class="apidocSignatureSpan">(opts, uniforms, attributes, stringStore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.shaderError" id="apidoc.element.regl.check.shaderError">
        function <span class="apidocSignatureSpan">regl.check.</span>shaderError
        <span class="apidocSignatureSpan">(gl, shader, source, type, command)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkShaderError(gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length &gt; 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + '\n', 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*\'(.*)\'\s*\:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + '\n', 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + '\n', 'font-weight:bold')
          })
          push(leftPad('| ', 6) + '\n')
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + '\n', 'color:red')
        }
      })
      if (typeof document !== 'undefined') {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var shader = cache[id]

  if (!shader) {
    var source = stringStore.str(id)
    shader = gl.createShader(type)
    gl.shaderSource(shader, source)
    gl.compileShader(shader)
    check.<span class="apidocCodeKeywordSpan">shaderError</span>(gl, shader, source, type, command)
    cache[id] = shader
  }

  return shader
}

// ===================================================
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.texture2D" id="apidoc.element.regl.check.texture2D">
        function <span class="apidocSignatureSpan">regl.check.</span>texture2D
        <span class="apidocSignatureSpan">(info, mipData, limits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkTexture2D(info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w &gt; 0 &amp;&amp; w &lt;= limits.maxTextureSize &amp;&amp;
        h &gt; 0 &amp;&amp; h &lt;= limits.maxTextureSize,
        'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) &amp;&amp; isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 &amp;&amp; h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &amp;&amp;
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &amp;&amp;
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &amp;&amp;
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) &amp;&amp; isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w &lt;&lt; 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') &lt; 0) {
      check(info.minFilter === GL_NEAREST &amp;&amp; info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i &lt; 16; ++i) {
    if (mipimages[i]) {
      var mw = w &gt;&gt; i
      var mh = h &gt;&gt; i
      check(mipData.mipmask &amp; (1 &lt;&lt; i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &amp;&amp;
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &amp;&amp;
        img.internalformat === mipData.internalformat &amp;&amp;
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask &amp; (1 &lt;&lt; i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (texInfo.genMipmaps) {
  mipData.mipmask = (mipData.width &lt;&lt; 1) - 1
}
texture.mipmask = mipData.mipmask

copyFlags(texture, mipData)

check.<span class="apidocCodeKeywordSpan">texture2D</span>(texInfo, mipData, limits)
texture.internalformat = mipData.internalformat

reglTexture2D.width = mipData.width
reglTexture2D.height = mipData.height

tempBind(texture)
setMipMap(mipData, GL_TEXTURE_2D)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.textureCube" id="apidoc.element.regl.check.textureCube">
        function <span class="apidocSignatureSpan">regl.check.</span>textureCube
        <span class="apidocSignatureSpan">(texture, info, faces, limits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkTextureCube(texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w &gt; 0 &amp;&amp; w &lt;= limits.maxTextureSize &amp;&amp; h &gt; 0 &amp;&amp; h &lt;= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE &amp;&amp; info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i &lt; faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w &amp;&amp; face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j &lt; 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w &gt;&gt; j
        var mh = h &gt;&gt; j
        check(face.mipmask &amp; (1 &lt;&lt; j), 'missing mipmap data')
        check(
          img.width === mw &amp;&amp;
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &amp;&amp;
          img.internalformat === texture.internalformat &amp;&amp;
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
            'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
copyFlags(texture, faces[0])
if (texInfo.genMipmaps) {
  texture.mipmask = (faces[0].width &lt;&lt; 1) - 1
} else {
  texture.mipmask = faces[0].mipmask
}

check.<span class="apidocCodeKeywordSpan">textureCube</span>(texture, texInfo, faces, limits)
texture.internalformat = faces[0].internalformat

reglTextureCube.width = faces[0].width
reglTextureCube.height = faces[0].height

tempBind(texture)
for (i = 0; i &lt; 6; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.check.type" id="apidoc.element.regl.check.type">
        function <span class="apidocSignatureSpan">regl.check.</span>type
        <span class="apidocSignatureSpan">(value, type, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkTypeOf(value, type, message) {
  if (typeof value !== type) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
destroyCallbacks.forEach(function (cb) {
  cb()
})
  }

  function compileProcedure (options) {
check(!!options, 'invalid args to regl({...})')
check.<span class="apidocCodeKeywordSpan">type</span>(options, 'object', 'invalid args to regl({...})')

function flattenNestedOptions (options) {
  var result = extend({}, options)
  delete result.uniforms
  delete result.attributes
  delete result.context
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.dynamic" id="apidoc.module.regl.dynamic">module regl.dynamic</a></h1>


    <h2>
        <a href="#apidoc.element.regl.dynamic.DynamicVariable" id="apidoc.element.regl.dynamic.DynamicVariable">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>DynamicVariable
        <span class="apidocSignatureSpan">(type, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DynamicVariable(type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return
    }
    var ref = env.invoke(block, value)
    block(objectRef, '.', key, '=', ref, ';')
  })
}

options.dynamic[name] = new dynamic.<span class="apidocCodeKeywordSpan">DynamicVariable</span>(DYN_THUNK, {
  thisDep: thisDep,
  contextDep: contextDep,
  propDep: propDep,
  ref: objectRef,
  append: appendBlock
})
delete options.static[name]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.accessor" id="apidoc.element.regl.dynamic.accessor">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>accessor
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toAccessorString(str) {
  return '[' + splitParts(str).join('][') + ']'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.define" id="apidoc.element.regl.dynamic.define">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>define
        <span class="apidocSignatureSpan">(type, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defineDynamic(type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.isDynamic" id="apidoc.element.regl.dynamic.isDynamic">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>isDynamic
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDynamic(x) {
  return (typeof x === 'function' &amp;&amp; !x._reglType) ||
         x instanceof DynamicVariable
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function separateDynamic (object) {
  var staticItems = {}
  var dynamicItems = {}
  Object.keys(object).forEach(function (option) {
    var value = object[option]
    if (dynamic.<span class="apidocCodeKeywordSpan">isDynamic</span>(value)) {
      dynamicItems[option] = dynamic.unbox(value, option)
    } else {
      staticItems[option] = value
    }
  })
  return {
    dynamic: dynamicItems,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.dynamic.unbox" id="apidoc.element.regl.dynamic.unbox">
        function <span class="apidocSignatureSpan">regl.dynamic.</span>unbox
        <span class="apidocSignatureSpan">(x, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unbox(x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  }
  return x
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    function separateDynamic (object) {
var staticItems = {}
var dynamicItems = {}
Object.keys(object).forEach(function (option) {
  var value = object[option]
  if (dynamic.isDynamic(value)) {
    dynamicItems[option] = dynamic.<span class="apidocCodeKeywordSpan">unbox</span>(value, option)
  } else {
    staticItems[option] = value
  }
})
return {
  dynamic: dynamicItems,
  static: staticItems
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.flatten" id="apidoc.module.regl.flatten">module regl.flatten</a></h1>


    <h2>
        <a href="#apidoc.element.regl.flatten.flatten" id="apidoc.element.regl.flatten.flatten">
        function <span class="apidocSignatureSpan">regl.</span>flatten
        <span class="apidocSignatureSpan">(array, shape, type, out_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenArray(array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i &lt; shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
var arrayShape = flattenUtils.shape(data)
var n = 1
for (var dd = 0; dd &lt; arrayShape.length; ++dd) {
  n *= arrayShape[dd]
}
var allocData = preConvert(image, n)
flattenUtils.<span class="apidocCodeKeywordSpan">flatten</span>(data, arrayShape, '', allocData)
postConvert(image, allocData)
image.alignment = 1
image.width = w
image.height = h
image.channels = c
image.format = image.internalformat = CHANNELS_FORMAT[c]
image.needsFree = true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.flatten.shape" id="apidoc.element.regl.flatten.shape">
        function <span class="apidocSignatureSpan">regl.flatten.</span>shape
        <span class="apidocSignatureSpan">(array_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayShape(array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var h = image.height || data.length
var c = image.channels
if (isArrayLike(data[0][0])) {
  c = c || data[0][0].length
} else {
  c = c || 1
}
var arrayShape = flattenUtils.<span class="apidocCodeKeywordSpan">shape</span>(data)
var n = 1
for (var dd = 0; dd &lt; arrayShape.length; ++dd) {
  n *= arrayShape[dd]
}
var allocData = preConvert(image, n)
flattenUtils.flatten(data, arrayShape, '', allocData)
postConvert(image, allocData)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.pool" id="apidoc.module.regl.pool">module regl.pool</a></h1>


    <h2>
        <a href="#apidoc.element.regl.pool.alloc" id="apidoc.element.regl.pool.alloc">
        function <span class="apidocSignatureSpan">regl.pool.</span>alloc
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function alloc(n) {
  var sz = nextPow16(n)
  var bin = bufferPool[log2(sz) &gt;&gt; 2]
  if (bin.length &gt; 0) {
    return bin.pop()
  }
  return new ArrayBuffer(sz)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.pool.allocType" id="apidoc.element.regl.pool.allocType">
        function <span class="apidocSignatureSpan">regl.pool.</span>allocType
        <span class="apidocSignatureSpan">(type, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allocType(type, n) {
  var result = null
  switch (type) {
    case GL_BYTE:
      result = new Int8Array(alloc(n), 0, n)
      break
    case GL_UNSIGNED_BYTE:
      result = new Uint8Array(alloc(n), 0, n)
      break
    case GL_SHORT:
      result = new Int16Array(alloc(2 * n), 0, n)
      break
    case GL_UNSIGNED_SHORT:
      result = new Uint16Array(alloc(2 * n), 0, n)
      break
    case GL_INT:
      result = new Int32Array(alloc(4 * n), 0, n)
      break
    case GL_UNSIGNED_INT:
      result = new Uint32Array(alloc(4 * n), 0, n)
      break
    case GL_FLOAT:
      result = new Float32Array(alloc(4 * n), 0, n)
      break
    default:
      return null
  }
  if (result.length !== n) {
    return result.subarray(0, n)
  }
  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (persist) {
    buffer.persistentData = flatData
  } else {
    pool.freeType(flatData)
  }
} else if (typeof data[0] === 'number') {
  buffer.dimension = dimension
  var typedData = pool.<span class="apidocCodeKeywordSpan">allocType</span>(buffer.dtype, data.length)
  copyArray(typedData, data)
  initBufferFromTypedArray(buffer, typedData, usage)
  if (persist) {
    buffer.persistentData = typedData
  } else {
    pool.freeType(typedData)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.pool.free" id="apidoc.element.regl.pool.free">
        function <span class="apidocSignatureSpan">regl.pool.</span>free
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function free(buf) {
  bufferPool[log2(buf.byteLength) &gt;&gt; 2].push(buf)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.pool.freeType" id="apidoc.element.regl.pool.freeType">
        function <span class="apidocSignatureSpan">regl.pool.</span>freeType
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function freeType(array) {
  free(array.buffer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  buffer.dimension = dim
  flatData = arrayFlatten(data, shape, buffer.dtype)
  initBufferFromTypedArray(buffer, flatData, usage)
  if (persist) {
    buffer.persistentData = flatData
  } else {
    pool.<span class="apidocCodeKeywordSpan">freeType</span>(flatData)
  }
} else if (typeof data[0] === 'number') {
  buffer.dimension = dimension
  var typedData = pool.allocType(buffer.dtype, data.length)
  copyArray(typedData, data)
  initBufferFromTypedArray(buffer, typedData, usage)
  if (persist) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.regl.raf" id="apidoc.module.regl.raf">module regl.raf</a></h1>


    <h2>
        <a href="#apidoc.element.regl.raf.cancel" id="apidoc.element.regl.raf.cancel">
        function <span class="apidocSignatureSpan">regl.raf.</span>cancel
        <span class="apidocSignatureSpan">(timer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cancel = function (timer) {
  if (timer &amp;&amp; (timer[kOnTimeout] || timer._onTimeout)) {
    timer[kOnTimeout] = timer._onTimeout = null;
    if (timer instanceof Timeout) {
      timer.close(); // for after === 0
    } else {
      unenroll(timer);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!activeRAF &amp;&amp; rafCallbacks.length &gt; 0) {
    activeRAF = raf.next(handleRAF)
  }
}

function stopRAF () {
  if (activeRAF) {
    raf.<span class="apidocCodeKeywordSpan">cancel</span>(handleRAF)
    activeRAF = null
  }
}

function handleContextLoss (event) {
  event.preventDefault()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.regl.raf.next" id="apidoc.element.regl.raf.next">
        function <span class="apidocSignatureSpan">regl.raf.</span>next
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (cb) { return setTimeout(cb, 16) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    timer.update()
  }
  activeRAF = null
  return
}

// schedule next animation frame
activeRAF = raf.<span class="apidocCodeKeywordSpan">next</span>(handleRAF)

// poll for changes
poll()

// fire a callback for all pending rafs
for (var i = rafCallbacks.length - 1; i &gt;= 0; --i) {
  var cb = rafCallbacks[i]
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>